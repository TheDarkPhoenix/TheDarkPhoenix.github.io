

[
  
  
    
    
      {
        "title": "Gry konsolowe",
        "excerpt": "Kółko i krzyżyk, Snake oraz Pong napisane w C++ w ramach projektu z Informatyki w Gimnazjum.\n\n\n",
        "content": "Kółko i krzyżyk, Snake oraz Pong napisane w C++ w ramach projektu z Informatyki w Gimnazjum.\n\nSnake\n\n  \n  \n\n\nKlasyczna gra, w której zbieramy wężem dolary. Do wyboru 3 tryby trudności, w których wąż różnie zmienia prędkość. Odpowiednio do trybu większa jest także nagroda za zbieranie punktów. Dostępny jest także ranking najlepszych graczy.\n\n  \n  \n\n\nSnake  github\n\n\nKółko i krzyżyk\n\n  \n  \n\n\nGrę kółko i krzyżyk napisałem na podstawie przykładu w kursie C++, który przerabiałem - “Od Zera do Gier Kodera”. Przeznaczona jest dla dwóch graczy. Ma format 3x3, pole do postawienia znaku wybiera się za pomocą odpowiednich cyfr. W programie sprawdzane są następnie ułożenia znaków, które prowadzą do remisu lub zwycięstwa jednego z graczy.\n\n  \n  \n\n\nTicTacToe  github\n\n\nPong\n\n  \n  \n\n\nGra przeznaczona dla dwóch graczy. Odbijamy piłkę aż do przepuszczenia jej przez jednego z graczy. Gra toczy się do ustalonej wcześniej ilości punktów.\n\n  \n  \n\n\nPong  github\n\n",
        "url": "/oprogramowanie/2013/05/31/gry-konsolowe/"
      },
    
      {
        "title": "Blu",
        "excerpt": "Gra, w której jeździmy samochodem po wzgórzach zbierając monety oraz paliwo. Wykonana w języku C++ wraz z bibliotekami SFML oraz Box2D.\n\n\n",
        "content": "Gra, w której jeździmy samochodem po wzgórzach zbierając monety oraz paliwo. Wykonana w języku C++ wraz z bibliotekami SFML oraz Box2D.\n\n\n  \n  \n\n\nGrę wykonałem w ramach projektu z Informatyki w Gimnazjum. Pomysł gry bazuje na popularnej w tym okresie grze Hill Climb Racing. Symulacja fizyczna gry oparta jest na bibliotece Box2D. Im dłużej jedziemy tym spotykamy trudniejsze wzgórza, zdobywamy monety o wyżeszej wartości oraz rzadziej znajdujemy paliwo. W tej grze dodałem także odgłosy silnika oraz muzykę.\n\n\n  \n  \n\n\nBlu  github\n\n",
        "url": "/oprogramowanie/2013/09/23/Blu/"
      },
    
      {
        "title": "2D Racing",
        "excerpt": "Gra wyścigowa 2D z widokiem od góry. Napisana w języku C++ przy pomocy bibliotek SFML oraz Box2D.\n\n\n",
        "content": "Gra wyścigowa 2D z widokiem od góry. Napisana w języku C++ przy pomocy bibliotek SFML oraz Box2D.\n\n\n  \n  \n\n\nGra ta została wykonana także w ramach projektu z Informatyki. Umożliwia ściganie się z przeciwnikami na różnych torach. Możemy także tworzyć własne trasy w osobnym edytorze, który także napisałem w ramach projektu. Tor podzielony jest na kwadraty o określonym typie: prosta, zekręt w lewo, prawo, trawa oraz meta.\n\n  \n  \n\n\nEdytor map  github\n\n\nDzięki zawarciu w pliku tekstowym informacji o odpowiednich kwadratach oraz odczycie aktualnej pozycji samochodu wprowadziłem pewną formę sztucznej inteligencji, z którą możemy się wyścigować. Przeciwnicy reagują na znalezienie się na fragmencie toru odpowiednio skręcaniem, przyspieszaniem lub hamowaniem. Cała symulacja jazdy oraz zderzeń oparta jest na bibliotece Box2D. Dzięki temu udało mi się uzyskać realistyczne interakcje między samochodami.\n\n  \n  \n\n\n2DRacing  github\n\n",
        "url": "/oprogramowanie/2014/01/18/2dracing/"
      },
    
      {
        "title": "Elektroniczna kostka",
        "excerpt": "Projekt elektronicznej kostki wykonany na podstawie przykładu w książce “Elektronika. Od praktyki do teorii”\n\n\n",
        "content": "Projekt elektronicznej kostki wykonany na podstawie przykładu w książce “Elektronika. Od praktyki do teorii”\n\n\n  \n  \n\n\nW układzie wykorzystany jest układ czasowy 555 do generacji impulsów, które następnie zliczane są w szóstkach. Odpowiednie liczby są wyświetlane na diodach. Proces zatrzymywany jest przez wciśnięcie przycisku co powoduje zatrzymanie się na “losowej” wartości. Impulsy są generowany na tyle szybko, że nie da sie wychwycić jaka aktualnie cyfra jest wyświetlana.\n\nProces wykonania:\n\n\n  \n  Prototyp na płytce stykowej\n\n\n\n  \n  Płytka uniwersalna wraz z użytymi elementami\n\n\n\n  \n  Zmontowana kostka\n\n",
        "url": "/elektronika/2014/03/22/elektronicznakostka/"
      },
    
      {
        "title": "Robot uniwersalny",
        "excerpt": "Miał robić kawę…\n\n\n",
        "content": "Miał robić kawę…\n\nTutaj wyobraźnia mnie poniosła i chciałem zrobić robota uniwersalnego zdolnego do wykonywania różnych czynności np. przygotować napoje, “chodzić” do sklepu. Oczywiście w zamyśle miała być to pierwsza wersja, na której chciałem zbadać moje możliwości. Podnosić miał jedynie atrapy, a poruszać się jedynie po domu.\n\n\n  \n  \n\n\nPiękna była to konstrukcja i bardzo skomplikowana. Do obsługi wszystkich kończyn planowałem zastosować 11 serw. Znacznie przekroczyło to liczbę kanałów PWM w mikrokontrolerze Atmega88Pa. Dlatego właśnie zmuszony byłem zastosować programowe generowanie PWM, które znacznie bardziej obciąża procesor. Z tego właśnie powodu zmuszony byłem użyć drugi mikrokontroler odpowiedzialny za komunikację z komputerem, sterowaniem silnikami oraz zadawanie poprzez SPI położeń serw do drugiego mikrokontrolera. Wiele rzeczy mogło się zepsuć po drodze, dlatego gdy ostatecznie nie mogłem zapanować nad serwami nie wiedziałem co się dzieje. Dopiero po dłuższym czasie doszedłem do wniosku, że musiałem mieć za słabe źródło zasilania, coś czego wcześniej nawet nie brałem pod uwagę. Jednak pomimo niedziałających serw nie porzuciłem tej konstrukcji. Wciąż miałem działające silniki, którymi mogłem sterować z poziomu komputera. Zająłem się w takim razie niezbędnym elementem takiego robota - wykrywaniem przeszkód oraz mapowaniem. W tym celu chciałem zasotosować parę stereowizyjną. Po wielu przygodach udało mi się wreszcie doprowadzić stereowizję do poziomu zadowalającego. Wciąż jednak występowało dużo szumów - szczególnie na podłodze. Nic dziwnego, podłoga, ściana, to mało szczegółów i ciężko jest uzyskać pewny obraz głębi. Udało się zatem mniej więcej wykrywać przeszkody, jednak gdy doszedł do tego ruch to już kompletnie co innego. Zastosowane kamerki internetowe zwracały poruszone obrazy co jeszcze pogarszało wynik wykrywania. Do tego nie zastosowałem enkoderów, ponieważ planowałem wykrywać punkty szczególne i póżniej na podstawie ich oraz uzyskanej mapy głębokości obliczać przesunięcie. Po takich jednak rozczarowujących efektach stereowizji nie próbowałem już tego rozwiązania.\n\n\n  \n  \n\n\nPomimo, że nie spełnił moich oczekiwań to wyszła z niego ciekawa konstrukcja. I mój początek przygody ze stereowizją i mapowaniem.\n\nW tej konstrukcji wzorowałem się na robocie PR2. Domyślną wersję tej konstrukcji chciałem wykonać 2 razy większą. Zastosowanie tutaj zgięcia w połowie miało na celu zwiększyć zakres chwytania - możliwość schylenia się. Jednak głównym celem była możliwość przetransformowania się w robota jeżdżącego, co umowżliwiłoby wspinanie się po schodach oraz większych przeszkodach. Domyślnie w napędzie chciałem zastosować gąsienice.\n\n",
        "url": "/roboty/2014/08/28/universal-robots/"
      },
    
      {
        "title": "3D Viewer",
        "excerpt": "Program służący do wyświetlania perspektywicznego punktów w 3D.\n\n\n",
        "content": "Program służący do wyświetlania perspektywicznego punktów w 3D.\n\n\n  \n  \n\n\nProgram ten napisałem w ramach lekcji Informatyki w Liceum. Zaimplementowałem wczytywanie chmur punktów z pliku txt. Są one w formacie współrzędne (X, Y, Z), a następnie kolory (R, G, B). Chmury punktów uzyskiwałem poprzez kamery stereowizyjne. Stworzyłem także możliwość wyświetlania kształtów geometrycznych, na przykład domku. Całość została napisana w Pascalu.\n\n\n  \n  \n\n\n3DViewer  github\n\n",
        "url": "/oprogramowanie/2015/04/09/3dviewer/"
      },
    
      {
        "title": "Efekt gitarowy Fuzz",
        "excerpt": "\n",
        "content": "Efekt gitarowy wykonany na podstawie schematu:\n\n  \n  \n\n",
        "url": "/elektronika/2015/06/20/fuzz/"
      },
    
      {
        "title": "Robot mapujący",
        "excerpt": "Robot laptopa wożący pokój mapujący.\n\n\n",
        "content": "Robot laptopa wożący pokój mapujący.\n\n\n  \n  \n\n\nTen robot jest drugą, uproszczoną wersją robota uniwersalnego. Wyciągając wnioski z poprzedniej konstrukcji uprościłem robota i jego jedynym zadaniem było mapowanie pomieszczeń. Także aby zadanie się udało zamieniłem Stereowizję na Kinecta, ponieważ rezultaty z niej osiągane nie były zadowalające. Dodałem także enkodery na koła, jednak wciąż zbyt pewny siebie zrobiłem swoje - inkrementalne bazujące na transoptorach. Nie sprawdzały się one idealnie, ale jednak pozwoliły osiągnąć rezultaty.\n\n\n  \n  Prototypowanie eletkroniki\n\n\nTakże w ramach zabawy z robotem zrealizowałem regulator PID i zadawałem punkt, do którego robot dojeżdżał.\n\nPID  github\n\n\n\n  \n  \n\n\nAby stworzyć mapę najpierw podrzebowałem odpowiednio obrobić dane. W danych głębi z Kinecta zawarte były informacje o podłodze oraz obiektach. Musiałem pozbyć się podłogi. Do osiągnięcia tego testowałem 2 metody: dopasowywanie płaszczyzny oparte na RANSACu z OpenCV oraz metodą UV-disparity, która przyspieszała obliczenia - wykrywałem linię zamiast płaszczyzny.\n\n\n  \n  \n\n\nNa tworzoną mapę typu Grid map nakładałem następnie wykryte obiekty. Do wyliczenia przesunięcia robota używałem wyłącznie enkoderów.\n\n  \n  \n\n\nMapowanie Kinect  github\n\n\n\n  \n  \n\n\nMapowanie Stereowizja  github\n\n\nPróbowałem także wykorzystać SLAMa, aby zniwelować niedoskonałości enkoderów. Jednak tutaj barierą był system operacyjny - Windows, na którym nie udało mi się uruchomić żadnej implementacji. Było to także zbyt skomplikowane zadanie jak na wiedzę, którą posiadałem, aby stworzyć własną implementację.\n\n\n  \n  \n\n\nDo sterowania robotem użyłem mikrokontrolera Atmega88Pa. Komunikował się on z komputerem poprzez interfejs UART, wykorzystałem tutaj przejściówkę na USB. Sterował on silnikami - serwami pracy ciągłej. Także mierzył napięcie z transoptorów, zliczając impulsy poprzez zastowanie odpowiedniego progu. Także dla testu wykorzystałem podczerwony czujnik odległości. Do zasilenia całej konstrukcji użyłem akumulatora żelowego. Poprzez mikrokontroler mierzyłem jego napięcie, sprawdzając czy się rozładował. Musiałem także zastosować przetwornicę Step-Up, aby zasilić Kinecta, który wymaga 12V.\n\nSterownik Robota  github\n\n",
        "url": "/roboty/2015/08/25/mapping-robot/"
      },
    
      {
        "title": "Cewka Tesli",
        "excerpt": "Robi się groźnie.\n\n\n",
        "content": "Robi się groźnie.\n\n\n  \n  \n\n\nProjekt cewki tesli wykonany na podstawie \nElectroBoom\noraz\nLudic Science\n\n\n  \n  \n\n\nNajpierw wykonałem mniejszą wersję opartą na jednym tranzystorze, zasilaną baterią 9V.\n\n\n  \n  Nawijanie cewki\n\n\nNastępnie wykonałem cewkę o większych rozmiarach, w ktrórej zastosowałem 4 tranzystory oraz dodatkowy radiator, aby zapewnić odpowiednie chłodzenie. Jako źródło energii użyłem zasilacza od drukarki.\n",
        "url": "/elektronika/2015/12/10/cewkatesli/"
      },
    
      {
        "title": "Świecąca kulka",
        "excerpt": "Robot laptopa wożący pokój mapujący.\n\n\n",
        "content": "Kontroler zainspirowany rozwiązaniem z PlayStation. Użyłem kamerki internetowej oraz odpowiedniego kontrolera - latarki z kulką. Ruchy kulki są śledzone oraz przekładane na ruchy kursora myszy. Poprzez odpowiednie przygaszenie a następnie zaświecenie latarki symulowane jest kliknięcie.\n\nW celu analizy obrazu użyłem bibliotekę OpenCV oraz metodę wykrywania przedstawioną w \n\n\n  \n  \n\n\nPID  github\n\n\n\n  \n  \n\n\n",
        "url": "/roboty/2017/05/26/move/"
      },
    
      {
        "title": "Hexapod",
        "excerpt": "Sześcionogi stwór z kamerkami.\n\n\n",
        "content": "Sześcionogi stwór z kamerkami.\n\nProjekt, którym zajmowałem się przez pierwsze 2 lata studiów w ramach działalności koła naukowego Integra. Moim wkładem było oprogramowanie do sterowania robota oraz stereowizji.\n\n\n  \n  \n\n\nDo poruszania konstrukcją wykorzystane zostało 18 serw Hitec po 3 na każdą nogę. Jako główny komputer robota wykorzystalismy Raspberry Pi 2. Komunikowała się ona z sterownikiem serw Pololu poprzez interfejs UART umożliwiając zadawanie odpowiednich pozycji serw. Całą konstrukcję zasila bateria LiPol o pojemności 4000 mAh, co pozwalało na ok. 1h użytkowania robota. Napięcie z akumulatora  dostowywaliśmy za pomocą przetwornic (3 do zasilania serw oraz 1 dla Raspberry). Wykorzystaliśmy także przetwornik ADC MCP3008, aby móc mierzyć aktualne napięcie na baterii. Komunikował się on z Raspberry za pomocą SPI, a następnie napięcie było wysyłane i wyświetlane w aplikacji klienta.\n\n\n  \n  \n\n\nRobot jest sterowany z poziomu laptopa, który komunikuje się z Raspberry poprzez WiFi przez protokół TCP. Do poruszania robotem można używać zarówno pada jak i klawiatury. W celu odpowiedniego sterowania najpierw napisałem aplikację obrazującą model matematyczny robota. Na tym modelu została zaimplementowana kinematyka odwrotna, na której następnie stworzyłem modele poruszania się robota. Odpowiednio przeliczone uzyskane kąty na sygnały PWM dla serwonapędów były wysyłane do sterownika.\n\n\n  \n  \n\n\nSterowanie robotem\nAplikacja uruchamiana na laptopie zawiera wizualizacje modelu robota oraz odbiera sygnały sterowania od użytkownika, które następnie przekazuje do programu na Raspberry. On natomiast dokonuje odpowiednich przeliczeń na sygnały PWM, które następnie przekazuje do sterownika serw. Z Raspberry wysyłana jest także informacja zwrotna do aplikacji użytkownika z aktualnym napięciem na baterii, dzięki czemu jej poziom jest na bieżąco monitorowany. Osobny program służy do realizacji stereowizji. Raspberry wysyła obrazy z obu kamer przy użyciu programu gstreamer. Na laptopie oba obrazy są odbierane i następnie przy użyciu odpowiednich macierzy (uzyskanych podczas kalibracji) przekształcana oraz liczona jest macierz obrazu dysparcji. Zastosowałem także filtr po przeliczeniu dysparcji, który dodatkowo poprawia rezultaty.\n\nAplikacje modelu Hexapoda można pracować w 2 trybach:\n\nTryb modelu\nW trybie modelu można poruszać się po środowisku za pomocą klawiszy W/S/A/D/Q/E oraz barów alfa, beta i gamma służących do zmiany kąta widzenia. Modelem robota poruszać można za pomocą klawiszy w/s/a/d/q/e oraz numerów służących do wyboru odpowiedniego trybu chodzenia robota.\n\n\n  \n  \n\n\nTryb połączenia z Hexapodem\nUruchamia się jeśli dodatkowo przekażemy do programu przy uruchomieniu adres IP Raspberry. Sterowanie aplikacją na laptopie nie zmienia się. Różnica z poprzednio omówionym trybem (tryb modelu) jest taka, iż teraz odpowiednie komendy wysyłane są także do Hexapoda. Dodatkowo wyświetlane na ekranie laptopa jest również napięcie na baterii.\n\nBliższy opis elementów zrealizowanej aplikacji\nGUI\nZadaniem najbardziej oddalonym od samej idei Hexapoda był moduł wyświetlania, czyli GUI. Do wyświetlania użyto wyłącznie prostego okienkowego trybu wyświetlania dołączonego do biblioteki OpenCV w celu debugowania. Zastosowałem rzutowanie perspektywiczne zgodnie ze wzorami zawartymi w 1, aby otrzymać symulację w 3D. Zdefiniowałem płaszczyznę kamery, na którą odbywało się rzutowanie świata 3D symulacji. Dodałęm także przesuwanie płaszczyzną kamery za pomocą przycisków oraz możliwość jej obracania przy pomocy toolbarów.\nRobot\nTo jest główny moduł odpowiedzialny za obliczenia związane ze sterowaniem robota. Zawarłem w nim implementację kinematyki odwrotnej w podejściu trygonometrycznym opisaną w 2. Główna klasa robota zawiera klasę nóg robota, które są wydzielone. Jest osobna klasa, w której znajdują się różne algorytmy chodzenia.\nChodzenie\nNajlepsze efekty dawało chodzenie po paraboli. Dobierane są kolejne punkty paraboli, która zaczyna się w miejscu, gdzie aktualnie znajduje się końcówka nogi robota. Kończy się tam, gdzie ma się ostatecznie znaleźć. Przy użyciu kinematyki odwrotnej wyliczane są kąty tak, aby końcówka danej nogi znalazła się w punkcie docelowym.\nPozostałe moduły\nKontroler, który odpowiednio interpretuje wysłane komendy na funkcje, np.: chodzenia lub poruszania bazą robota. Znajduje się tutaj również moduł do komunikacji z serwami (tylko w wersji programu dla Raspberry). Zamieniane są wyliczone kąty dla każdej nogi na odpowiednie sygnały PWM, dla każdego serwa (jedna noga składa się z trzech serwonapędów). Następnie są one wysyłane.\nTCP\nW module TCP znajduję się cały kod do komunikacji pomiędzy Raspberry a laptopem. Kod został zaczerpnięty z 3. W ramach komunikacji laptop łączy się z Raspberry i na porcie 8081 odbiera aktualne napięcie baterii, które Raspberry stale udostępnia. Komunikacja w ramach odczytu napięcia baterii odbywa się w osobnym wątku, aby nie zakłócać pozostałych operacji. Natomiast na port 8080 aplikacja z laptopa wysyła podane komendy.\n\nAplikacja na laptopa  github\n\n\nAplikacja na Raspberry  github\n\n\nStereowizja\nPoniżej przedstawie krótki opis etapów realizacji stereowizji:\nWykonanie zdjęć kalibracyjnych\nAby skalibrować parę stereowizyjną wykonywane są zdjęcia ustalonego wzoru, np. szachownicy. W tym celu napisałem aplikację, która wyświetlała obraz z obu kamer. Co ustalony czas zapisywała zdjęcie pod odpowiednią nazwą oraz tworzyła listę utworzonych obrazów. Wykonałem około 50 zdjęć tak, aby jak najlepiej pokryć cały obszar widoku kamer.\n\n\n  \n  Przykładowa para zdjęć wykonanych podczas kalibracji\n\n\nWidoczny na zdjęciach zamieszczonych powyżej jest także następny napotkany problem - obiektywy w obudowach kamer zamontowane były nierówno. Oczywiście to przesunięcie eliminowane jest podczas kalibracji, jednak w rezultacie podczas właściwej stereowizji ograniczone jest pole widzenia od góry i dołu (część pixeli widoczna jest tylko przez jedną kamerkę).\nKalibracja\nDo samej kalibracji użyłem przykładu z książki Learning OpenCV. W parametrach wywołania umieszczano wysokość oraz szerokość szachownicy (liczba pól), a także długość boku kwadratu w centymetrach. Bardzo ważne jest, aby szachownica miała kwadratowe pola, gdyż przy użyciu szachownicy o bokach różniących się nieznacznie cały proces kalibracji zostałby przeprowadzony niepoprawnie wraz z listą zdjęć, powstałych w trakcie tej błędnej kalibracji.\n\n\n  \n  Wynik wykrywania krawędzi szachownicy\n\n\n\n  \n  Wynik rektyfikacji\n\n\nW wyniku działania kalibracji otrzymałem parametry zewnętrzne oraz wewnętrzne kamer, które następnie używane były do właściwej stereowizji. Uzyskano błędy:\nbłąd średniokwadratowy (RMS) = 0.0503053\nśredni błąd epipolarny = 0.517146\nSą to wartości niskie, co świadczy o poprawnie wykonanej kalibracji.\nWybór algorytmu oraz dobranie parametrów\nNajpierw przetestowałem dostępne w bibliotece OpenCV algorytmy BM i SGBM, lepsze rezultaty uzyskałem dla SGBM. Jest on bardziej wymagający obliczeniowo, aczkolwiek przy rozdzielczości 320x240 można było uzyskać dobre przetwarzanie w czasie rzeczywistym. Następnie dobrałem optymalne parametry dla tego algorytmu. W tym celu napisałem aplikację na podstawie przykładu użycia SGBM zawartego w bibliotece OpenCV. Dodałem do niej suwak tak, aby można było wygodnie zmieniać parametry i obserwować uzyskiwane rezultatu.\n\n\n  \n  Widok okna z paskami do zmiany parametrów\n\n\n\n  \n  Przykładowa scena użyta do doboru parametrów\n\n\n\n  \n  Wynik przeprowadzenia stereowizji\n\n\nDobranie parametrów dla postfiltracji\nW celu uzyskania gładszego obrazu stereowizyjnego zastosowałem postfiltrację, która dodana została stosunkowo niedawno do modułów dodatkowych biblioteki OpenCV - contrib.\n\n\n  \n  Efekt przeprowadzenia algorytmu SGBM przy optymalnych parametrach\n\n\n\n  \n  Efekt przeprowadzenia postfiltracji\n\n\nOstateczna aplikacja\nW ostatecznej aplikacji połączone zostały wszystkie opisane elementy. W wyniku czego otrzymano przesył obrazu z obu kamer na laptopa. Tam obraz był rektyfikowany, a pixele były dopasowywane za pomocą algorytmu SGBM. Przy użyciu posfiltracji obraz dysparcji jest poprawiany i na koniec wyświetlany. Dalszym etapem rozwojowym może być przeliczenie chmury punktów na podstawie dysparcji oraz następnie wykrywanie i omijanie przeszkód.\n\nPoza samą realizacją stereowizji ważnym elementem był także optymalny przesył obrazu z obu kamer. Pierwszym podejściem było użycie MJPGstreamera. Efekty jednak nie były zadowalające. Klatki, które nie zostały jeszcze wysłane, były składowane w buforze. W wyniku czego, im dłużej działała aplikacja, tym większe było opóźnienie. Dodatkowo występowała różnica czasu pomiędzy klatkami z obu kamer, co w przypadku stereowizji jest nieakceptowalne. Dlatego zdecydowano się użyć gstreamera. Jest on bardziej zaawansowany, przez co uruchomienie go zajęło więcej czasu. Jednak uzyskany efekt jest bardzo dobry. W jego działaniu, jeśli nie zdąży się wysłać klatki przed przybyciem następnej, to zostaje ona porzucona. W wyniku tego wyeliminowane zostało rosnące opóźnienie. Dlatego też nie występowało już opóźnienie pomiędzy klatkami. Rozdzielczość przesyłanych obrazów wynosi 320x240. Przeprowadzono także testy dla rozdzielczości 640x480, ale spadek FPS był nieproporcjonalny do wzrostu jakości.\n\nStereowizja  github\n\n\nOsiągnięcia\nZawody robotyczne\n\n  Robocomp 2017 w Krakowie (kategoria Freestyle)\n  Robotic Arena 2017 we Wrocławiu (kategorie Freestyle oraz wyścig robotów kroczących). Pierwsze miejsce w kategorii wyścig robotów kroczących.\n  Robomaticon 2018 w Warszawie (kategoria Freestyle)\n  Robotic Tournament 2018 w Rybniku (kategoria Freestyle)\n  Robotic Arena 2019 we Wrocławiu. Drugie miejsce w kategorii wyścig robotów kroczących.\n    Wydarzenia\n  \n  Targi pracy Kariera IT\n  TEDxAGHUniversity\n\n\n\n  \n  Prezentacja na zawodach Robotic Arena fot. Politechnika Wrocławska\n\n\nStrona projektu\n",
        "url": "/roboty/2018/06/08/hexapod/"
      },
    
      {
        "title": "Czołg",
        "excerpt": "Pojazd uniwersalny oparty o Raspberry Pi Zero.\n\n\n",
        "content": "Pojazd uniwersalny oparty o Raspberry Pi Zero.\n\n\n  \n  \n\n\nUmożliwia obserwację obrazu z kamerki, odczyt napięcia na baterii (poziom rozładowania ), temperatury z Raspberry oraz wartości enkoderów. Dotychczas odczytów z enkoderów nie wykorzystałem w sposób praktyczny, jednak zamieszczenie ich umożliwi dalszy rozwój konstrukcji.\n\n\n  \n  \n\n\nProjekt ten zaczął się od płytki PCB.\n\n  \n  Płytka wraz z podłączonymi wszystkimi elementami\n\n\nMiała być wykorzystana do sterowania robotem z następującymi elementami:\n\n  dwa silniki z enkoderami\n  trzy serwa\n  komunikacja z Raspberry pooprzez SPI\n  pomiar napięcia z baterii\n  dwa LEDy ( uruchomienie oraz rozładowanie)\n\n\n\n  \n  Złożony schemat prototypowany na płytce stykowej\n\n\nJako źródło zasilania wykorzystałem LiPola oraz 2 przetwornicę: jedną do logigki oraz drugą do serw. W trakcie realizacji projektu jednak zorientowałem się, że ten mikrokontroler jest za słaby. Było to spowodowane tym, że potrzebowałem 3 kanałów PWM do serw oraz 2 do sterowania prędkością silników. Nie miałem jednak dostępnej takiej liczby, dlatego sygnały PWM dla serw musiałem generować programowo, przez co znacznie wzrosło obciążenie procesora. Doliczając do tego bardzo często przerwania zewnętrzne z dwóch enkoderów, nie byłem w stanie dostarczyć wystarczająco dokładnego przebiegu PWM by sterować serwami. Dlatego ostatecznie pominąłem użycie serw w tym projekcie.\n\n\n  \n  \n\n\nKonstrukcja czołgu została wykonana na drukarce 3D, a jej projekt zaczerpnąłem z \nhttps://www.thingiverse.com/thing:652851\n\n\n  \n  Płytka po wytrawieniu\n\n\nRobotem steruje się poprzez przeglądarkę. W tym celu użyłem skryptu z https://hackaday.io/project/25092-zerobot-raspberry-pi-zero-fpv-robot/log/97988-the-new-zerobot-pro\n,który odpowiednio przerobiłem do swoich potrzeb ( zamiana sterowania na takie wykorzystujące SPI).\n\nProjekt  github\n\n",
        "url": "/roboty/2019/03/27/tank/"
      },
    
  
  
  
  {
    "title": "Categories",
    "excerpt": "Category index\n",
    "content": "\n",
    "url": "/categories/"
  },
  
  {
    "title": "Projekty",
    "excerpt": "Category index\n",
    "content": "\n",
    "url": "/categories/"
  }
  
]

