

[
  
  
    
    
      {
        "title": "Gry konsolowe",
        "excerpt": "Kółko i krzyżyk, Snake oraz Pong napisane w C++ w ramach projektu z Informatyki w Gimnazjum.\n\n",
        "content": "Kółko i krzyżyk, Snake oraz Pong napisane w C++ w ramach projektu z Informatyki w Gimnazjum.\n\nSnake\n\n  \n  \n\n\nKlasyczna gra, w której zbieramy wężem dolary. Do wyboru 3 tryby trudności, w których wąż różnie zmienia prędkość. Odpowiednio do trybu większa jest także nagroda za zbieranie punktów. Dostępny jest także ranking najlepszych graczy.\n\n  \n  \n\n\nSnake  github\n\n\nKółko i krzyżyk\n\n  \n  \n\n\nGrę kółko i krzyżyk napisałem na podstawie przykładu w kursie C++, który przerabiałem - “Od Zera do Gier Kodera”. Przeznaczona jest dla dwóch graczy. Ma format 3x3, pole do postawienia znaku wybiera się za pomocą odpowiednich cyfr. W programie sprawdzane są następnie ułożenia znaków, które prowadzą do remisu lub zwycięstwa jednego z graczy.\n\n  \n  \n\n\nTicTacToe  github\n\n\nPong\n\n  \n  \n\n\nGra przeznaczona dla dwóch graczy. Odbijamy piłkę aż do przepuszczenia jej przez jednego z graczy. Gra toczy się do ustalonej wcześniej ilości punktów.\n\n  \n  \n\n\nPong  github\n\n",
        "url": "/oprogramowanie/2013/05/31/gry-konsolowe/"
      },
    
      {
        "title": "Blu",
        "excerpt": "Gra, w której jeździmy samochodem po wzgórzach zbierając monety oraz paliwo. Wykonana w języku C++ wraz z bibliotekami SFML oraz Box2D.\n\n",
        "content": "Gra, w której jeździmy samochodem po wzgórzach zbierając monety oraz paliwo. Wykonana w języku C++ wraz z bibliotekami SFML oraz Box2D.\n\n\n  \n  \n\n\nGrę wykonałem w ramach projektu z Informatyki w Gimnazjum. Pomysł gry bazuje na popularnej w tym okresie grze Hill Climb Racing. Symulacja fizyczna gry oparta jest na bibliotece Box2D. Im dłużej jedziemy tym spotykamy trudniejsze wzgórza, zdobywamy monety o wyżeszej wartości oraz rzadziej znajdujemy paliwo. W tej grze dodałem także odgłosy silnika oraz muzykę.\n\n\n  \n  \n\n\nBlu  github\n\n",
        "url": "/oprogramowanie/2013/09/23/Blu/"
      },
    
      {
        "title": "2D Racing",
        "excerpt": "Gra wyścigowa 2D z widokiem od góry. Napisana w języku C++ przy pomocy bibliotek SFML oraz Box2D.\n\n",
        "content": "Gra wyścigowa 2D z widokiem od góry. Napisana w języku C++ przy pomocy bibliotek SFML oraz Box2D.\n\n\n  \n  \n\n\nGra ta została wykonana także w ramach projektu z Informatyki. Umożliwia ściganie się z przeciwnikami na różnych torach. Możemy także tworzyć własne trasy w osobnym edytorze, który także napisałem w ramach projektu. Tor podzielony jest na kwadraty o określonym typie: prosta, zekręt w lewo, prawo, trawa oraz meta.\n\n  \n  \n\n\nEdytor map  github\n\n\nDzięki zawarciu w pliku tekstowym informacji o odpowiednich kwadratach oraz odczycie aktualnej pozycji samochodu wprowadziłem pewną formę sztucznej inteligencji, z którą możemy się wyścigować. Przeciwnicy reagują na znalezienie się na fragmencie toru odpowiednio skręcaniem, przyspieszaniem lub hamowaniem. Cała symulacja jazdy oraz zderzeń oparta jest na bibliotece Box2D. Dzięki temu udało mi się uzyskać realistyczne interakcje między samochodami.\n\n  \n  \n\n\n2DRacing  github\n\n",
        "url": "/oprogramowanie/2014/01/18/2dracing/"
      },
    
      {
        "title": "3D Viewer",
        "excerpt": "Program służący do wyświetlania perspektywicznego punktów w 3D.\n\n",
        "content": "Program służący do wyświetlania perspektywicznego punktów w 3D.\n\n\n  \n  \n\n\nProgram ten napisałem w ramach lekcji Informatyki w Liceum. Zaimplementowałem wczytywanie chmur punktów z pliku txt. Są one w formacie współrzędne (X, Y, Z), a następnie kolory (R, G, B). Chmury punktów uzyskiwałem poprzez kamery stereowizyjne. Stworzyłem także możliwość wyświetlania kształtów geometrycznych, na przykład domku. Całość została napisana w Pascalu.\n\n\n  \n  \n\n\n3DViewer  github\n\n",
        "url": "/oprogramowanie/2015/04/09/3dviewer/"
      },
    
      {
        "title": "Hexapod",
        "excerpt": "Sześcionogi stwór z kamerkami.\n\n",
        "content": "Sześcionogi stwór z kamerkami.\n\nProjekt, którym zajmowałem się przez pierwsze 2 lata studiów w ramach działalności koła naukowego Integra. Moim wkładem było oprogramowanie to sterowania robota oraz stereowizji.\n\n\n  \n  \n\n\nDo poruszania konstrukcją wykorzystane zostało 18 serw Hitec po 3 na każdą nogę. Jako główny komputer robota wykorzystalismy Raspberry Pi 2. Komunikowała się ona z sterownikiem serw Pololu poprzez interfejs UART umożliwiając zadawanie odpowiednich pozycji serw. Całą konstrukcję zasila bateria LiPol o pojemności 4000 mAh, co pozwalało na ok. 1h użytkowania robota. Napięcie z akumulatora  dostowywaliśmy za pomocą przetwornic (3 do zasilania serw oraz 1 dla Raspberry). Wykorzystaliśmy także przetwornik ADC MCP3008, aby móc mierzyć aktualne napięcie na baterii. Komunikował się on z Raspberry za pomocą SPI, a następnie napięcie było wysyłane i wyświetlane w aplikacji klienta.\n\nOprogramowanie\n\n\n  \n  \n\n\nRobot jest sterowany z poziomu laptopa, który komunikuje się z Raspberry poprzez WiFi przez protokół TCP. Do poruszania robotem można używać zarówno pada jak i klawiatury. W trakcie pokazów stosowaliśmy pad do Xboxa. W celu odpowiedniego sterowania najpierw została napisana aplikacja przy użyciu języka C++ oraz biblioteki OpenCV obrazującą model matematyczny robota. Na tym modelu została zaimplementowana kinematyka odwrotna, na której następnie stworzono modele poruszania się robota. Odpowiednio przeliczono uzyskane kąty na sygnały PWM dla serwonapędów, które następnie były wysyłane do sterownika.\nAplikacja\nOstatecznie aplikacja została rozdzielona na dwie. Jedna jest uruchamiana na laptopie. Zawiera wizualizacje modelu robota. Do drugiej są wysyłane odpowiednie komendy, na które fizycznie reaguje. Z Raspberry wysyłana jest informacja do aplikacji z aktualnym napięciem na baterii, dzięki czemu jej poziom jest na bieżąco monitorowany. Dodatkowa aplikacja służy do realizacji stereowizji. Raspberry wysyła obrazy z obu kamer przy użyciu programu gstreamer, który daje lepsze efekty pod względem opóźnień, co do innego popularnego programu MJPG streamer. Na laptopie oba obrazy są odbierane. Następnie przy użyciu odpowiednich macierzy - uzyskanych podczas kalibracji - przekształcana oraz liczona jest macierz obrazu dysparcji. Zastosowano także filtr po przeliczeniu dysparcji, który dość znacznie poprawia uzyskane rezultaty.\n\nAplikacja modelu Hexapoda\nAplikacje można pracować w 2 trybach:\npo podaniu adresu IP Raspberry laptop się z nią połączy i będzie wysyłać odpowiednie komunikaty\nbez podania adresu będzie funkcjonować tylko jako model Hexapoda\nTryb modelu\nW trybie modelu można poruszać się po środowisku za pomocą klawiszy W/S/A/D/Q/E oraz barów alfa, beta i gamma służących do zmiany kąta widzenia. Modelem robota poruszać można za pomocą klawiszy w/s/a/d/q/e oraz numerów służących do wyboru odpowiedniego trybu chodzenia robota.\n\n\n  \n  \n\n\nTryb połączenia z Hexapodem\nSterowanie aplikacją na laptopie nie zmienia się. Różnica z poprzednio omówionym trybem (tryb modelu) jest taka, iż teraz odpowiednie komendy wysyłane są także do Hexapoda. Dodatkowo wyświetlane na ekranie laptopa jest również napięcie na baterii.\n\n\n  \n  \n\n\n\n  \n  \n\n\nBliższy opis zrealizowanej aplikacji\nGUI\nZadaniem najbardziej oddalonym od samej idei Hexapoda był moduł wyświetlania, czyli GUI. Do wyświetlania użyto wyłącznie prostego okienkowego trybu wyświetlania dołączonego do biblioteki OpenCV w celu debugowania. Zastosowano rzutowanie perspektywiczne zgodnie ze wzorami zawartymi w [1], aby otrzymać symulację w 3D. Zdefiniowano płaszczyznę kamery, na którą odbywało się rzutowanie świata 3D symulacji. Dodano przesuwanie płaszczyzną kamery za pomocą przycisków oraz możliwość jej obracania przy pomocy toolbarów.\nRobot\nTo jest główny moduł odpowiedzialny za obliczenia związane ze sterowaniem robota. Zawarto w nim implementację kinematyki odwrotnej w podejściu trygonometrycznym opisaną w [2]. Główna klasa robota zawiera klasę nóg robota, które są wydzielone. Jest osobna klasa, w której znajdują się różne algorytmy chodzenia.\nChodzenie\nNajlepsze efekty dawało chodzenie po paraboli. Dobierane są kolejne punkty paraboli, która zaczyna się w miejscu, gdzie aktualnie znajduje się końcówka nogi robota. Kończy się tam, gdzie ma się ostatecznie znaleźć. Przy użyciu kinematyki odwrotnej wyliczane są kąty tak, aby końcówka danej nogi znalazła się w punkcie docelowym.\nPozostałe moduły\nUmieszczono model kontrolera, który odpowiednio interpretuje wysłane komendy na funkcje, np.: chodzenia lub poruszania bazą robota. Znajduje się tutaj również moduł do komunikacji z serwami (tylko w wersji programu dla Raspberry). Zamieniane są wyliczone kąty dla każdej nogi na odpowiednie sygnały PWM, dla każdego serwa (jedna noga składa się z trzech serwonapędów). Następnie są one wysyłane.\nTCP\nW module TCP znajduję się cały kod do komunikacji pomiędzy Raspberry a laptopem. Kod został zaczerpnięty z [3]. W ramach komunikacji laptop łączy się z Raspberry i na porcie 8081 odbiera aktualne napięcie baterii, które Raspberry stale udostępnia. Komunikacja w ramach odczytu napięcia baterii odbywa się w osobnym wątku, aby nie zakłócać pozostałych operacji. Natomiast na port 8080 aplikacja z laptopa wysyła podane komendy.\n\nAplikacja na laptopa  github\n\n\nAplikacja na Raspberry  github\n\n\nAplikacja Stereowizji\nEtapy realizacji stereowizji\nWykonanie zdjęć kalibracyjnych\nAby skalibrować parę stereowizyjną wykonywane są zdjęcia ustalonego wzoru, np. szachownicy. W tym celu napisano aplikację, która wyświetlała obraz z obu kamer. Co ustalony czas zapisywała zdjęcie pod odpowiednią nazwą oraz tworzyła listę utworzonych obrazów. Wykonano około 50 zdjęć tak, aby jak najlepiej pokryć cały obszar widoku kamer.\n\n\n  \n  Przykładowa para zdjęć wykonanych podczas kalibracji\n\n\nWidoczny na zdjęciach zamieszczonych powyżej jest także następny napotkany problem - obiektywy w obudowach kamer zamontowane były nierówno. Oczywiście to przesunięcie eliminowane jest podczas kalibracji, jednak w rezultacie podczas właściwej stereowizji ograniczone jest pole widzenia od góry i dołu (część pixeli widoczna jest tylko przez jedną kamerkę).\nKalibracja\nDo samej kalibracji użyto przykładu z książki Learning OpenCV. W parametrach wywołania umieszczano wysokość oraz szerokość szachownicy (liczba pól), a także długość boku kwadratu w centymetrach. Bardzo ważne jest, aby szachownica miała kwadratowe pola, gdyż przy użyciu szachownicy o bokach różniących się nieznacznie cały proces kalibracji zostałby przeprowadzony niepoprawnie wraz z listą zdjęć, powstałych w trakcie tej błędnej kalibracji.\n\n\n  \n  Wynik wykrywania krawędzi szachownicy\n\n\n\n  \n  Wynik rektyfikacji\n\n\nW wyniku działania kalibracji otrzymano parametry zewnętrzne oraz wewnętrzne kamer, które następnie używane były do właściwej stereowizji. Uzyskano błędy:\nbłąd średniokwadratowy (RMS) = 0.0503053\nśredni błąd epipolarny = 0.517146\nSą to wartości niskie, co świadczy o poprawnie wykonanej kalibracji.\nWybór algorytmu oraz dobranie parametrów\nNajpierw przetestowano dostępne w bibliotece OpenCV algorytmy BM i SGBM. Lepsze rezultaty uzyskano dla SGBM. Jest on bardziej wymagający obliczeniowo, aczkolwiek przy rozdzielczości 320x240 można było uzyskać dobre przetwarzanie w czasie rzeczywistym. Następnie dobrano optymalne parametry dla tego algorytmu. W tym celu napisano aplikację na podstawie przykładu użycia SGBM zawartego w bibliotece OpenCV. Dodano do niej suwak tak, aby można było wygodnie zmieniać parametry i obserwować uzyskiwane rezultatu. Następnie dla przykładowej pary obrazów dobierano parametry w taki sposób, aby uzyskać jak najlepsze efekty.\n\n\n  \n  Widok okna z paskami do zmiany parametrów\n\n\n\n  \n  Przykładowa scena użyta do doboru parametrów\n\n\n\n  \n  Wynik przeprowadzenia stereowizji dla jednego zestawu parametrów\n\n\n\n  \n  Wynik przeprowadzenia stereowizji dla innej pary parametrów\n\n\nDobranie parametrów dla postfiltracji\nW celu uzyskania gładszego obrazu stereowizyjnego zastosowano postfiltrację, która dodana została stosunkowo niedawno do modułów dodatkowych biblioteki OpenCV - contrib.\n\n\n  \n  Efekt przeprowadzenia algorytmu SGBM przy optymalnych parametrach\n\n\n\n  \n  Efekt przeprowadzenia postfiltracji\n\n\nJak widać po przeprowadzeniu postfiltracji znacznie poprawił się uzyskany rezultat.\nOstateczna aplikacja\nW ostatecznej aplikacji połączone zostały wszystkie opisane elementy. W wyniku czego otrzymano przesył obrazu z obu kamer na laptopa. Tam obraz był rektyfikowany, a pixele były dopasowywane za pomocą algorytmu SGBM. Przy użyciu posfiltracji obraz dysparcji jest poprawiany i na koniec wyświetlany. Dalszym etapem rozwojowym może być przeliczenie chmury punktów na podstawie dysparcji oraz następnie wykrywanie i omijanie przeszkód.\n\nEtapy działania stereowizji\nrektyfikacja na podstawie parametrów uzyskanych podczas kalibracji\nSGBM z parametrami wcześniej wyznaczonymi\npostfiltracja\n\nPoza samą realizacją stereowizji ważnym elementem był także optymalny przesył obrazu z obu kamer. Pierwszym podejściem było użycie MJPGstreamera. Efekty jednak nie były zadowalające. Klatki, które nie zostały jeszcze wysłane, były składowane w buforze. W wyniku czego, im dłużej działała aplikacja, tym większe było opóźnienie. Dodatkowo występowała różnica czasu pomiędzy klatkami z obu kamer, co w przypadku stereowizji jest nieakceptowalne. Dlatego zdecydowano się użyć gstreamera. Jest on bardziej zaawansowany, przez co uruchomienie go zajęło więcej czasu. Jednak uzyskany efekt jest bardzo dobry. W jego działaniu, jeśli nie zdąży się wysłać klatki przed przybyciem następnej, to zostaje ona porzucona. W wyniku tego wyeliminowane zostało rosnące opóźnienie. Dlatego też nie występowało już opóźnienie pomiędzy klatkami. Rozdzielczość przesyłanych obrazów wynosi 320x240. Przeprowadzono także testy dla rozdzielczości 640x480, ale spadek FPS (ang. “Frames per second”), czyli klatek na sekundę, był nieproporcjonalny do wzrostu jakości.\n\nOsiągnięcia\nZawody robotyczne\n\n  Robocomp 2017 w Krakowie (kategoria Freestyle)\n  Robotic Arena 2017 we Wrocławiu (kategorie Freestyle oraz wyścig robotów kroczących). Podczas tych zawodów zajęto pierwsze miejsce w kategorii wyścig robotów kroczących.\n  Robomaticon 2018 w Warszawie (kategoria Freestyle)\n  Robotic Tournament 2018 w Rybniku (kategoria Freestyle)\n    Wydarzenia\n  \n  Targi pracy Kariera IT\n  TEDxAGHUniversity\n\n",
        "url": "/roboty/2018/06/08/hexapod/"
      },
    
  
  
  
  {
    "title": "Categories",
    "excerpt": "Category index\n",
    "content": "\n",
    "url": "/categories/"
  },
  
  {
    "title": "Projekty",
    "excerpt": "Category index\n",
    "content": "\n",
    "url": "/projekty/"
  },
  
  {
    "title": "Blog",
    "excerpt": "\n",
    "content": "\n",
    "url": "/blog/"
  }
  
]

